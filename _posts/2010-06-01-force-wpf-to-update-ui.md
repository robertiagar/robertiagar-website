---
layout: post
title: Force WPF to update UI
date: 2010-06-01 20:44
author: "Robert Iagar"
comments: true
tags: [Design, WPF, WPF]
---
<p>I’ve recently posted a Twitter Client to <a href="http://twitby.codeplex.com">codeplex.com</a> and I’ve been frustrated that I can’t seem to manually update when the tweet was posted. So I’ve started thinking a came up with this solution.</p> <!--more-->  <p>First create a Model that is derived from INotifyPropertyChanged and create the specific members:    <br />    <br />public event PropertyChangedEventHandler PropertyChanged;</p>  <p>protected void OnPropertyChanged(string propertyName)    <br />{     <br />&#160;&#160;&#160;&#160;&#160; if (PropertyChanged != null)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; PropertyChanged(this, new PropertyChangedEventArgs(propertyName));     <br />}</p>  <p>Define your properties:&#160; <br />    <br />private DateTime _timeAgo;     <br />    <br />public string TimeAgo     <br />{     <br />&#160;&#160;&#160;&#160;&#160; get { return _timeAgo.ToRelativeTime(); //TweetSharp Extension }     <br />&#160;&#160;&#160;&#160;&#160; set     <br />&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _timeAgo = DateTime.Parse(value);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OnPropertyChanged(“TimeAgo”);     <br />&#160;&#160;&#160;&#160;&#160; }     <br />}</p>  <p>Now define a System.Timers.Timer:</p>  <p>using System.Timers;    <br />private Timer _timer = new Timer(){ Interval = 30000 //30000 miliseconds = 30 seconds };     <br />private bool TimerFlag = true;</p>  <p>Modify your OnPropertyChanged method and add a new method to handle the Timer’s Elapsed event:</p>  <p>protected void OnPropertyChanged(string propertyName)    <br />{     <br />&#160;&#160;&#160;&#160;&#160; if(TimerFlag)     <br />&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _timer.Elapsed +=&#160; new ElapsedEventHandler(_timer_Elapsed);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; _timer.Start();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TimerFlag = false;     <br />&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160; if (PropertyChanged != null)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; PropertyChanged(this, new PropertyChangedEventArgs(propertyName));     <br />}     <br />    <br />private void _timer_Elapsed(object sender, ElapsedEventArgs e)     <br />{     <br />&#160;&#160;&#160;&#160;&#160; OnPropertyChanged(“TimeAgo”);     <br />}</p>  <p>Now I’m not sure how effective is this way but it seems to do the job for me. This only works for this kind of a scenario, because once the Model returns the TimeAgo, WPF’s DataBinding System doesn’t know if the property is changing over time. To it, it’s just a string. In other scenario’s when you change the property WPF’s DataBinding System knows that because of the OnPropertyChanged in set.    <br />    <br />Simple, not sure if elegant but definitely works.</p>  <p>Can’t wait to hear your opinions on this.</p>
